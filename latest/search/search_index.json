{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>This documentation describes the language specification of the cQASM quantum programming language, version 3.0-beta1. cQASM stands for common Quantum ASseMbly language, and is pronounced c-kazem.</p> <p>cQASM 3.0-beta1 supersedes the cQASM 1.[012] languages and cQASM 2.0 language specification, the latter of which remains incomplete.</p> <p>Note</p> <p>Even though cQASM 3.0-beta1 is conceptually similar to previous language specifications, it is not a straightforward extension thereof; the syntax and grammar of cQASM 3.0-beta1 differ fundamentally from its predecessors. These changes break backwards compatibility.</p> <p>In the rest of the documentation we will drop the version label of language and simply refer to it as the cQASM language.</p> <p>Warning</p> <p>The cQASM language is currently under active development.  cQASM 3.0-beta1 serves as a minimum viable product; to be used as a baseline version for the further development of, e.g., the libQASM language parser library, OpenSquirrel quantum algorithm compiler, and QX simulator. The cQASM specification will be updated as new features are introduced to the language. Where applicable, these features are then also implemented in the aformentioned software components, in an iterative fashion.</p>"},{"location":"appendices/spin.html","title":"Spin-2","text":"<p>The Spin-2 system developed by QuTech supports the following subset of the cQASM language:</p> <ul> <li>Multiple line comments in <code>/* \u2026 */</code> are supported.</li> <li>Single line comments in <code>// \u2026</code>, <code># \u2026</code>, <code>/* \u2026*/</code> are supported.</li> <li>A program must start with <code>version 3.0</code>.</li> <li>The version must be followed by a single declaration of the format <code>qubit[1-4] &lt;varname&gt;</code> or <code>qubit &lt;varname&gt;</code>, where   the latter implies <code>qubit[1] &lt;varname&gt;</code>.</li> <li>The only accepted gates/operations are (case sensitive!): configurable (currently, <code>X90</code>, <code>mX90</code>, <code>Y90</code>, <code>mY90</code>, <code>Rz</code>,   <code>CZ</code>)</li> <li><code>&lt;varname&gt;</code> must be used to denote a qubit</li> <li>The single-gate-multiple-qubit (SGMQ) notation is fully supported for single qubit gates</li> <li>The SGMQ notation is not supported for two qubit gates.</li> <li>The SGMQ notation results in a bundle resulting in a sequential list of gate operations.</li> <li>Subcircuit headers are accepted (and subsequently ignored).</li> <li>All other libqasm 1.x language structures are not supported.</li> <li>No <code>prep_X</code> and <code>measure_X</code> instructions are allowed, the lls will init all supported qubits before circuit execution   and measure all in the z-basis at the end of the circuit and only return the subset as defined in the qubit register.</li> <li>Bit register declaration statements, e.g., <code>bit[&lt;number-of-bits:INT&gt;] &lt;bit-register-name:ID&gt;</code> or <code>bit &lt;bit-name:ID&gt;</code>, are accepted and subsequently ignored.</li> <li>Measure instruction statements assign outcomes to bit variables, e.g. <code>&lt;bit-name:BIT&gt; = measure &lt;qubit-argument:QUBIT&gt;</code>. These statements are accepted and subsequently ignored.</li> </ul>"},{"location":"introduction/acknowledgements.html","title":"Acknowledgements","text":"<p>Quantum Inspire: support@quantum-inspire.com</p>"},{"location":"introduction/context.html","title":"Context","text":"<p>The update of cQASM was motivated by, and developed within the context of, the overhaul of Quantum Inspire.</p>"},{"location":"introduction/history.html","title":"History","text":"<p>Coming soon</p>"},{"location":"language_specification/general_overview.html","title":"General overview","text":"<p>The cQASM language specification consists of a description of its Tokens, Statements, Types, and Expressions. Additional information is provided on the case sensitivity of the language, the preferred file extension of a cQASM program, and a brief explanation on how to interpret the grammar sections of this specification.</p>"},{"location":"language_specification/general_overview.html#tokens","title":"Tokens","text":"<p>A cQASM program can contain the following types of tokens:</p> <ul> <li>Newlines</li> <li>Literals</li> <li>Identifiers</li> <li>Keywords</li> <li>Operators and punctuators </li> </ul> <p>Whitespace and comments are ignored except as they serve to separate tokens.</p>"},{"location":"language_specification/general_overview.html#statements","title":"Statements","text":"<p>A cQASM program consists of a sequence of statements. Among those, a quantum algorithm is in essence a sequence of instructions: gates and non-unitary quantum operations applied to qubit arguments (e.g., the measure instruction).</p> <ul> <li>Version statement (mandatory)</li> <li>Qubit (register) declaration</li> <li>Bit (register) declaration</li> <li>Gates</li> <li>Measure instruction</li> </ul> Example cQASM programSmallest valid cQASM program <pre><code>// Example program according to the cQASM language specification\n\n// Version statement\nversion 3.0\n\n// Qubit register declaration\nqubit[2] q\n\n// Bit register declaration\nbit[2] b\n\n// Gates\nH q[0]\nCNOT q[0], q[1]\n\n// Measurement statement\nb[0, 1] = measure q[0, 1]\n</code></pre> <pre><code>version 3\n</code></pre>"},{"location":"language_specification/general_overview.html#types","title":"Types","text":"<p>The set of types supported by cQASM can be found in the section Types. </p>"},{"location":"language_specification/general_overview.html#expressions","title":"Expressions","text":"<p>The following expressions can appear in a statement:</p> <ul> <li>Indices</li> <li>Predefined constants</li> <li>Built-in functions</li> </ul>"},{"location":"language_specification/general_overview.html#case-sensitivity","title":"Case sensitivity","text":"<p>cQASM is now a case-sensitive language, in contrast to previous versions.  The following lines of code are all semantically distinct</p> <pre><code>H q[0]\nh Q[0]\n</code></pre> <p>In the first line of the example above, the Hadamard gate <code>H</code> is applied to the qubit at index <code>0</code> of the qubit register <code>q</code>. The next line starts with an undefined gate <code>h</code>  that operates on the qubit at index <code>0</code> of the qubit register <code>Q</code>, which in turn does not refer to the qubit register <code>q</code>.</p> <p>Take care that case sensitivity not only applies to identifiers, but also to all other lexical components of the language, like keywords, types, predefined constants, and built-in functions.</p> <p>Note</p> <p>Gate names are identifiers and are therefore case-sensitive. The syntax of the gates defined in cQASM are listed in the cQASM standard gate set. Even though it is common practice to write variable names or function identifiers in lowercase, we choose to define the gate names in the predefined cQASM standard gate set in UPPERCASE or CamelCase, as this is more in line with how these gates are represented in the field of quantum information processing (QIP). </p>"},{"location":"language_specification/general_overview.html#file-extension","title":"File extension","text":"<p>The preferred file extension for a cQASM file is <code>*.cq</code>.</p>"},{"location":"language_specification/general_overview.html#about-the-grammar-sections","title":"About the grammar sections","text":"<p>In the notation and grammar descriptions appearing throughout this language specification,  syntactic categories are indicated by italic type, and literal words and characters in <code>bold constant width</code> type. Alternatives are listed on separate lines except in a few cases where a long set of alternatives is presented on one line, with the quantifiers 'one of', 'through', or 'or'. For example,</p> <p>\u2003one of <code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code></p> <p>indicates any lowercase or uppercase alphabetic character.</p> <p>An optional terminal or non-terminal symbol is indicated by the subscript <sub>opt</sub>, so</p> <p> <code>{</code> expression<sub>opt</sub><code>}</code></p> <p>indicates an optional expression enclosed in curly braces.</p> <p>Names for syntactic categories have generally been chosen according to the following rules:</p> <ul> <li>X-sequence is one or more X\u2019s without intervening delimiters, e.g., digit-sequence is a sequence of digits.</li> <li>X-list is one or more X\u2019s separated by intervening commas, e.g., index-list is a sequence of  indices separated by commas.</li> </ul>"},{"location":"language_specification/types.html","title":"Types","text":"<p>The table below lists the available types in a cQASM program.</p> Type Keyword Form Qubit <code>qubit</code> <code>qubit</code> identifier QubitArray <code>qubit</code> <code>qubit[</code>size<code>]</code>identifier Bit <code>bit</code> <code>bit</code> identifier BitArray <code>bit</code> <code>qubit[</code>size<code>]</code>identifier <p>Note</p> <p>Type keywords are reserved and, therefore, cannot be used as identifiers.</p>"},{"location":"language_specification/expressions/builtin_functions.html","title":"Built-in functions","text":"<p>Coming soon</p>"},{"location":"language_specification/expressions/indices.html","title":"Indices","text":"<p>An index is a reference to one or more positions within a register. The first position of a register is 0. Positions are expressed as a list of comma-separated entries. Each entry can be a single integer or a range. A range is written as two integers separated by a colon, pointing to a first and to a last element within a register. The last position is also part of the range, i.e., it does not point to the first element out of the range.</p> <p>Grammar for indices</p> <p>index: identifier <code>[</code> index-list <code>]</code></p> <p>index-list: index-entry index-list <code>,</code> index-entry</p> <p>index-entry: integer-literal index-range</p> <p>index-range: index-entry <code>:</code> index-entry</p> <p>Indices, index entries, and index ranges</p> <pre><code>// Qubit register containing 7 qubits, numbered from 0 to 6\nqubit[7] q \n\n// q[1, 3:5] is a qubit index with two entries: \n// the first entry points to qubit 1 in q, and the second to qubits 3, 4, and 5\nH q[1, 3:5]\n</code></pre>"},{"location":"language_specification/expressions/predefined_constants.html","title":"Predefined constants","text":"<p>The following mathematical constants are recognized: <code>pi</code>, <code>tau</code>, and <code>eu</code>, where <code>tau</code> is \\(2\\pi\\) and <code>eu</code> represents Euler's constant \\(e\\). They are stored as floating-point number literals and can be used in arithmetic expressions with operators, e.g., <code>pi/2</code> equals \\(\\tfrac{\\pi}{2}\\). </p> <p>The latter can be used, for example, as an argument for a parameterized gate, i.e.,</p> <p> <code>Rx(pi/2) q[0]</code></p>"},{"location":"language_specification/statements/bit_register_declaration.html","title":"Bit (register) declaration","text":"<p>A bit or bit register must be declared before they can be used. The general form is given as follows:</p> <p> <code>bit[</code>size<code>]</code>identifier</p> Grammar for bit (register) declaration <p>bit-declaration: <code>bit</code> array-size-declaration<sub>opt</sub> identifier</p> <p>array-size-declaration: <code>[</code>integer-literal<code>]</code> </p> <p>Its form is similar to the declaration of an arbitrary variable, whereby the type of the variable is specified first, i.e. <code>bit</code> denotes that the declared variable is of type Bit. and <code>bit[</code>size<code>]</code> denotes that the declared variable is of type BitArray. The size of a bit register is declared by an integer value between square brackets <code>[</code>size<code>]</code>. The name of the bit (register) is defined through an identifier. </p> <p>The declaration of a bit (register) is optional, Nevertheless, since measurement outcomes are stored as bits, measure instructions require a previously declared bit (register).</p> <p>Find below examples, respectively, of a single bit declaration and bit register declaration.</p> <p>Example</p> Single bit declarationBit register declaration <pre><code>version 3\n\nqubit q\nqubit b  // Single bit declaration of a bit named 'b'.\n\nH q\n\nb = measure q\n</code></pre> <pre><code>version 3\n\nqubit[5] q\nbit[2] b  // Bit register declaration of a register containing 2 bits, named 'b'.\n\nH q[0]\nCNOT q[0], q[1]\n\nb[0] = measure q[0]\nb[1] = measure q[1]\n</code></pre> <p>The individual bits of a bit register can be referred to by their register index, e.g. in the example of the Bit register declaration, the statement <code>b[0] = measure q[0]</code> indicates that the measurement outcome is stored at the bit located at index <code>0</code> of the bit register <code>b</code>.  Note that in the case of a single bit, the bit is referred to through its identifier, not through a register index.</p>"},{"location":"language_specification/statements/gates.html","title":"Gates","text":"<p>Gates define single-qubit or multi-qubit unitary operations that change the state of a qubit register in a deterministic fashion. The general form of a gate is given by the gate name followed by the (comma-separated list of) qubit operand(s), e.g., <code>X q[0]</code>:</p> <p> gate qubit-arguments</p> <p>Parameterized unitary operations are represented by parameterized gates. The general form of a parameterized gate is given by the gate name followed by its (comma-separated list of) parameter(s) that is enclosed in parentheses, which in turn is followed by the (comma-separated list of) qubit operand(s), e.g., <code>CRk(2) q[0], q[1]</code>:</p> <p> gate<code>(</code>parameters<code>)</code> qubit-arguments</p> <p>Note that the parameters, either single or a list of multiple parameters, appear within parentheses directly following the gate name. We distinguish between the parameters of a parameterized gate, in terms of number literals, and the qubit arguments that a (parameterized) gate acts on.</p> Grammar for gates <p>gate: identifier parameters<sub>opt</sub> qubit-arguments</p> <p>parameters: <code>(</code> parameter-list <code>)</code></p> <p>parameter-list: parameter parameter-list <code>,</code> parameter</p> <p>parameter: integer-literal floating-literal</p> <p>qubit-arguments: qubit-argument-list</p> <p>qubit-argument-list: qubit-argument qubit-argument-list <code>,</code> qubit-argument</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>A few examples of gates are shown below.</p> <pre><code>// A single-qubit Hadamard gate\nH q[0]\n\n// A two-qubit controlled-Z gate (control: q[0], target: q[1])\nCZ q[0], q[1]\n\n// A parameterized single-qubit Rx gate (with \u03c0/2 rotation around the x-axis)\nRx(pi/2) q[0]\n\n// A parametrized two-qubit controlled phase-shift gate (control: q[1], target: q[0])\nCRk(2) q[1], q[0]\n</code></pre> <p>The gates that are supported by the cQASM language are listed in the standard gate set.</p>"},{"location":"language_specification/statements/gates.html#single-gate-multi-qubit-sgmq-notation","title":"Single-gate-multi-qubit (SGMQ) notation","text":"<p>It is possible to pass multiple qubits as an argument to a single-qubit gate, by making use of the single-gate-multi-qubit (SGMQ) notation. The single-qubit gate will then be applied to each qubit, respectively.</p> <p>Note</p> <p>SGMQ notation does not imply that the gates are, necessarily, executed in parallel on the target device.  SGMQ notation is nothing other than syntactic sugar, whereby a series of instruction statements can be written as one. Moreover, SGMQ notation should not be confused with multiple-qubit gates, e.g.,  <code>X q[0,1]</code> means <code>X q[0]; X q[1]</code>, and does not represent the 2-qubit gate <code>XX q[0], q[1]</code>. Note that the latter 2-qubit gate <code>XX</code> is currently not supported by the cQASM language, see the standard gate set below.</p> <p>If the name of the qubit register is <code>q</code>, then the following can be passed as an argument to the single-qubit gate:</p> <ul> <li> <p>the whole qubit register <code>q</code>;</p> </li> <li> <p>a slice thereof <code>q[i:j]</code>, where \\(0 \\leq i &lt; j &lt; N\\);</p> </li> <li> <p>or a list of indices can be passed <code>q[i,]</code>, where \\(0 \\leq i &lt; N\\),</p> </li> </ul> <p>with \\(N\\) the size of the qubit register. The following slicing convention is adopted: a slice <code>q[i:j]</code> includes qubits <code>q[i]</code>, <code>q[j]</code>, and all qubits in between. The code block below demonstrates some examples.</p> <p>Example</p> The whole qubit registerA slice of the qubit registerA list of indices of the qubit register <pre><code>qubit[5] q\n\nX q  // is semantically equivalent to:\nX q[0]; X q[1]; X q[2]; X q[3]; X q[4]\n</code></pre> <pre><code>qubit[5] q\n\nX q[1:3]  // is semantically equivalent to:\nX q[1]; X q[2]; X q[3]\n</code></pre> <pre><code>qubit[5] q\n\nX q[0,2,4]  // is semantically equivalent to:\nX q[0]; X q[2]; X q[4] \n</code></pre> <p>In the above examples we have used the semicolon <code>;</code> to separate statements occurring on the same line.</p>"},{"location":"language_specification/statements/gates.html#standard-gate-set","title":"Standard gate set","text":"Name Description Example statement I Identity gate <code>I q[0]</code> H Hadamard gate <code>H q[0]</code> X Pauli-X <code>X q[0]</code> X90 Rotation around the x-axis of \\(\\pi/2\\) <code>X90 q[0]</code> mX90 Rotation around the x-axis of \\(-\\pi/2\\) <code>mX90 q[0]</code> Y Pauli-Y <code>Y q[0]</code> Y90 Rotation around the y-axis of \\(\\pi/2\\) <code>Y90 q[0]</code> mY90 Rotation around the y-axis of \\(-\\pi/2\\) <code>mY90 q[0]</code> Z Pauli-Z <code>Z q[0]</code> S Phase gate <code>S q[0]</code> Sdag S dagger gate <code>Sdag q[0]</code> T T <code>T q[0]</code> Tdag T dagger gate <code>Tdag q[0]</code> Rx Arbitrary rotation around x-axis <code>Rx(pi) q[0]</code> Ry Arbitrary rotation around y-axis <code>Ry(pi) q[0]</code> Rz Arbitrary rotation around z-axis <code>Rz(pi) q[0]</code> CNOT Controlled-NOT gate <code>CNOT q[0], q[1]</code> CZ Controlled-Z, Controlled-Phase <code>CZ q[0], q[1]</code> CR Controlled phase shift (arbitrary angle) <code>CR(pi) q[0], q[1]</code> CRk Controlled phase shift (\\(\\pi/2^k\\)) <code>CRk(2) q[0], q[1]</code>"},{"location":"language_specification/statements/measure_instruction.html","title":"Measure instruction","text":"<p>A <code>measure</code> instruction performs a measurement to its qubit argument and assigns the outcome to a bit variable. The general form of a measure instruction is as follows:</p> <p> bit-argument <code>=</code> <code>measure</code> qubit-argument</p> Grammar for measure instruction <p>measure: bit-argument <code>=</code> <code>measure</code> qubit-argument</p> <p>bit-argument: bit-variable bit-index</p> <p>bit-variable: identifier</p> <p>bit-index: index</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Example</p> Measurement of a single qubitMeasurement of multiple qubits through their register index <pre><code>qubit q\nbit b\nb = measure q\n</code></pre> <pre><code>qubit[5] q\nbit[2] b\nb[0, 1] = measure q[2, 4]\n</code></pre> <p>Note</p> <p>The measure instruction accepts SGMQ notation, similar to gates.</p> <p>The following code snippet shows how the measure instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\n\nb = measure q  // Measurement in the standard basis.\n</code></pre> <p>On the last line of this simple cQASM program, the respective states of both qubits in the qubit register are measured along the standard/computational basis.</p>"},{"location":"language_specification/statements/qubit_register_declaration.html","title":"Qubit (register) declaration","text":"<p>A qubit (register) must be declared before it can be used. The general form is given as follows:</p> <p> <code>qubit[</code>size<code>]</code>identifier</p> Grammar for bit (register) declaration <p>qubit-declaration: <code>qubit</code> array-size-declaration<sub>opt</sub> identifier</p> <p>array-size-declaration: <code>[</code> integer-literal <code>]</code> </p> <p>Its form is similar to the declaration of an arbitrary variable, whereby the type of the variable is specified first, i.e. <code>qubit</code> denotes that the declared variable is of type Qubit. and <code>qubit[</code>size<code>]</code> denotes that the declared variable is of type QubitArray. The size of a qubit register is declared by an integer value between square brackets <code>[</code>size<code>]</code>. The name of the qubit (register) is defined through an identifier. </p> <p>The declaration of a qubit (register) is optional. </p> <p>Note</p> <p>The qubit (register) declaration replaces the qubit statement, i.e., </p> <p> <code>qubits</code> size</p> <p>of previous versions of the cQASM language.</p> <p>Find below examples, respectively, of a single qubit declaration and qubit register declaration.</p> <p>Example</p> Single qubit declarationQubit register declaration <pre><code>version 3\n\nqubit q  // Single qubit declaration of a qubit named 'q'.\nqubit b\n\nH q\n\nb = measure q\n</code></pre> <pre><code>version 3\n\nqubit[5] q  // Qubit register declaration of a register containing 5 qubits, named 'q'.\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\n\nb[0, 1] = measure q[0, 1]\n</code></pre> <p>The individual qubits of a qubit register can be referred to by their register index, e.g., in the example of the Qubit register declaration, the statement <code>H q[0]</code> indicates the application of a Hadamard gate <code>H</code> on the qubit located at index <code>0</code> of the qubit register <code>q</code>.  Note that in the case of a single qubit,  the qubit is referred to through its identifier, not through a register index.</p> <p>Qubits, either declared as a single qubit or as elements of a register, are presumed to be initialized in the state \\(|0\\rangle\\) of the standard/computational basis.</p>"},{"location":"language_specification/statements/version_statement.html","title":"Version statement","text":"<p>The version statement is mandatory and indicates which version of the cQASM language the program is written in. Apart from comments, it must be the first statement of the program and occur only once. It has the following general form:</p> <p> <code>version</code> major-version<code>.</code>minor-version</p> Grammar for version statement <p>version: <code>version</code> major-version minor-version-suffix<sub>opt</sub></p> <p>major-version: digit-sequence</p> <p>minor-version-suffix: <code>.</code> minor-version</p> <p>minor-version: digit-sequence</p> <p>where the version number is to be given as two period separated integers, respectively indicating the major and minor version of the cQASM language. It is permitted to only specify the major version number, i.e., the specification of the minor version number is optional. In that case, the minor-version will be interpreted as <code>0</code>.</p> <p>Example</p> <pre><code>// Only comments may appear before the version statement.\nversion 3.0\n</code></pre>"},{"location":"language_specification/tokens/identifiers.html","title":"Identifiers","text":"<p>An identifier is a single character or a sequence of characters of the following form: upper or lowercase letters from the ISO basic Latin alphabet, underscore, and digits, with the constraint that the first (or singular) character cannot be a digit.</p> <p>For now, they are used to name a (qu)bit (registers) by the user, and predefine the names of useful mathematical constants, built-in functions, and gates. Note that identifiers are not protected, i.e. they can be reused.  For example, it is permissible, however discouraged, to name a (qu)bit (register) <code>pi</code>, <code>cos</code>, or <code>Rx</code>.</p> <p>Reserved keywords cannot be used as an identifier.</p> Grammar for identifiers <p>identifier: letter identifier letter identifier digit</p> <p>letter:  one of <code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code> or <code>_</code> </p> <p>Examples</p> Valid identifiersInvalid identifiers <pre><code>q\n_i\nID\nb01\n</code></pre> <pre><code>1q     // first character cannot be a digit\n+q     // the underscore '_' is the only permissible special character \nqubit  // 'qubit' is a reserved keyword\n</code></pre>"},{"location":"language_specification/tokens/keywords.html","title":"Keywords","text":"<p>Keywords constitute identifiers reserved by the language parser.  As such, they have a specific predefined meaning and cannot be overwritten or used as a general identifier, e.g., as the name of the (qu)bit register.</p> <p>The table below lists the reserved keywords in cQASM:</p> Keyword Use <code>version</code> Version statement <code>qubit</code> Qubit type <code>bit</code> Bit type <code>measure</code> Measure instruction"},{"location":"language_specification/tokens/literals.html","title":"Literals","text":"<p>The only literals accepted as tokens are integer and float numbers. </p> Literal Size / precision Integer 64-bit signed Float IEEE 754 double precision Grammar of number literals <p>integer-literal: digit-sequence</p> <p>floating-literal: digit-sequence <code>.</code> digit-sequence exponent<sub>opt</sub> digit-sequence <code>.</code> exponent<sub>opt</sub> <code>.</code> digit-sequence exponent<sub>opt</sub></p> <p>exponent: <code>e</code> sign<sub>opt</sub> digit-sequence <code>E</code> sign<sub>opt</sub> digit-sequence</p> <p>sign: one of <code>+</code> <code>-</code></p> <p>digit-sequence: digit digit-sequence digit</p> <p>digit: one of <code>0</code> through <code>9</code> </p>"},{"location":"language_specification/tokens/newlines.html","title":"Newlines","text":"<p>cQASM is newline-sensitive, i.e. a newline terminates a statement.</p> <p>A semicolon <code>;</code> may be used instead of a newline to separate statements, for instance when putting multiple statements on the same line. Semicolons can also be put at the end of the line for clarity without changing the semantics of the program.</p>"},{"location":"language_specification/tokens/operators_and_punctuators.html","title":"Operators and punctuators","text":"<p>The lexical representation of a cQASM program includes a number of tokens that serve as operators and punctuators.</p> <p>Grammar of operators and punctuators</p> <p>operators-and-punctuators: one of <code>;</code> <code>:</code> <code>,</code> <code>.</code> <code>=</code> <code>[</code> <code>]</code> <code>(</code> <code>)</code> <code>+</code> <code>-</code> <code>~</code> <code>!</code> <code>\\*\\*</code> <code>\\*</code> <code>/</code> <code>%</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code> <code>&amp;</code> <code>^</code> <code>|</code> <code>&amp;&amp;</code> <code>^^</code> <code>||</code> <code>?</code></p>"},{"location":"language_specification/tokens/whitespace_and_comments.html","title":"Whitespace and comments","text":"<p>In general, cQASM is not whitespace-sensitive, apart from newlines. Spaces and tabs can be placed in between tokens.</p> <p>Comments can be written as single-line comments or as multi-line comments within a comment block. Only comments can appear before the version statement. Whitespace before a single-line or multi-line comment is permitted.</p>"},{"location":"language_specification/tokens/whitespace_and_comments.html#single-line-comment","title":"Single-line comment","text":"<p>A single-line comment is prefixed by two forward slashes <code>//</code> and finishes with the new line,  equal to the syntax of C-like languages.</p> <p>The general form of single-line comments is as follows</p> <p> <code>//</code> single-line-comment statement statement <code>//</code> single-line-comment</p> <p>Example</p> <pre><code>// This is a single-line comment, which ends on the new line.\nH q[0]\nCNOT q[0], q[1]  // A single-line comment can follow a statement.\n</code></pre>"},{"location":"language_specification/tokens/whitespace_and_comments.html#multi-line-comments","title":"Multi-line comments","text":"<p>Multi-line comment blocks allow for writing comments that span multiple lines.  A comment block starts with the combination of a forward slash and an asterisk <code>/*</code> and end with the combination of an asterisk and a forward slash <code>*/</code>.</p> <p>The general structure of a multi-line comment is given by</p> <p> <code>/*</code> multi-line comment-block <code>*/</code> </p> <p> statement <code>/*</code> multi-line comment-block <code>*/</code> statement</p> <p>An example of multi-line commenting is given by the following:</p> <p>Example</p> <pre><code>/* This is a multi-\nline comment. */\nCNOT q[0], /* A comment block can\nbe placed in between tokens. */ q[1]\n</code></pre> <p>A pair of forward slashes <code>//</code> may be part of a multi-line comment block. In that case they are considered part of the comment and not the start of a single-line comment.</p>"}]}