{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>This documentation describes the language specification of the cQASM quantum programming language, version 3.0-beta1. cQASM stands for common Quantum ASseMbly language, and is pronounced c-kazem.</p> <p>cQASM 3.0-beta1 supersedes the cQASM 1.[012] languages and cQASM 2.0 language specification, the latter of which remains incomplete.</p> <p>Note</p> <p>Even though cQASM 3.0-beta1 is conceptually similar to previous language specifications, it is not a straightforward extension thereof; the syntax and grammar of cQASM 3.0-beta1 differ fundamentally from its predecessors. These changes break backwards compatibility.</p> <p>In the rest of the documentation we will drop the version label of language and simply refer to it as the cQASM language.</p> <p>Warning</p> <p>The cQASM language is currently under active development.  cQASM 3.0-beta1 serves as a minimum viable product; to be used as a baseline version for the further development of, e.g., the libQASM language parser library, OpenSquirrel quantum algorithm compiler, and QX simulator. The cQASM specification will be updated as new features are introduced to the language. Where applicable, these features are then also implemented in the aformentioned software components, in an iterative fashion.</p>"},{"location":"appendices/spin_2plus.html","title":"Spin-2+","text":"<p>The Spin-2+ system developed by QuTech supports the following subset of the cQASM language:</p> <ul> <li>Multiple line comments in <code>/* \u2026 */</code> are supported.</li> <li>Single line comments in <code>// \u2026</code>, <code># \u2026</code>, <code>/* \u2026*/</code> are supported.</li> <li>A program must start with <code>version 3.0</code>.</li> <li>The version must be followed by a single declaration of the format <code>qubit[1-4] &lt;varname&gt;</code> or <code>qubit &lt;varname&gt;</code>, where   the latter implies <code>qubit[1] &lt;varname&gt;</code>.</li> <li>The only accepted gates/operations are (case sensitive!): configurable (currently, <code>X90</code>, <code>mX90</code>, <code>Y90</code>, <code>mY90</code>, <code>Rz</code>,   <code>CZ</code>)</li> <li><code>&lt;varname&gt;</code> must be used to denote a qubit</li> <li>The single-gate-multiple-qubit (SGMQ) notation is fully supported for single qubit gates</li> <li>The SGMQ notation is not supported for two qubit gates.</li> <li>The SGMQ notation results in a bundle resulting in a sequential list of gate operations.</li> <li>All other libqasm 1.x language structures are not supported.</li> <li>No <code>prep_X</code> and <code>measure_X</code> instructions are allowed, the lls will init all supported qubits before circuit execution   and measure all in the z-basis at the end of the circuit and only return the subset as defined in the qubit register.</li> <li>Bit register declaration statements, e.g., <code>bit[&lt;number-of-bits:INT&gt;] &lt;bit-register-name:ID&gt;</code> or <code>bit &lt;bit-name:ID&gt;</code>, are accepted and subsequently ignored.</li> <li>Measure instruction statements assign outcomes to bit variables, e.g. <code>&lt;bit-name:BIT&gt; = measure &lt;qubit-argument:QUBIT&gt;</code>. These statements are accepted and subsequently ignored.</li> </ul>"},{"location":"introduction/acknowledgements.html","title":"Acknowledgements","text":"<p>Quantum Inspire: support@quantum-inspire.com</p>"},{"location":"introduction/context.html","title":"Context","text":"<p>The update of cQASM was motivated by, and developed within the context of, the overhaul of Quantum Inspire.</p>"},{"location":"introduction/history.html","title":"History","text":"<p>Coming soon</p>"},{"location":"language_specification/general_overview.html","title":"General overview","text":"<p>The cQASM language specification consists of a description of its tokens, statements, types, and expressions. Additional information is provided on the case sensitivity of the language, the preferred file extension of a cQASM program, and a brief explanation on how to interpret the grammar sections of this specification.</p>"},{"location":"language_specification/general_overview.html#tokens","title":"Tokens","text":"<p>A cQASM program can contain the following types of tokens:</p> <ul> <li>Newlines</li> <li>Literals</li> <li>Identifiers</li> <li>Keywords</li> <li>Raw text string</li> <li>Operators and punctuators </li> </ul> <p>Whitespace and comments are ignored except as they serve to separate tokens.</p>"},{"location":"language_specification/general_overview.html#statements","title":"Statements","text":"<p>A cQASM program consists of a list of statements, more concretely, a version statement followed by variable declarations and instructions.  In essence, a quantum algorithm is expressed via a sequence of unitary and non-unitary quantum operations applied to qubit arguments (e.g., the measure instruction). The unitary operations, commonly know as gates, can be either named gates or compositions of gate modifiers acting on a named gate.</p> <p>Note</p> <p>For simplicity, throughout this documentation, we use the term gate to refer to a named gate. However, it is important to note that the result of applying a gate modifier is also a gate. When we need to refer explicitely to a named gate such as <code>H</code> or <code>Rz</code>, and not to a gate resulting from applying a gate modifier, we use the term named gate.</p> <ul> <li>Version statement (mandatory)</li> <li>Variable declarations:<ul> <li>Qubit (register) declaration</li> <li>Bit (register) declaration</li> </ul> </li> <li>Instructions:<ul> <li>Unitary instructions (i.e., gates)</li> <li>Non-unitary instructions:<ul> <li>Init instruction</li> <li>Measure instruction</li> <li>Reset instruction</li> </ul> </li> <li>Control instructions:<ul> <li>Barrier instruction</li> <li>Wait instruction</li> </ul> </li> <li>Single-gate-multiple-qubit (SGMQ) notation</li> </ul> </li> <li>Assembly declaration</li> </ul> Example cQASM programSmallest valid cQASM program <pre><code>// Example program according to the cQASM language specification\n\n// Version statement\nversion 3.0\n\n// Qubit register declaration\nqubit[2] q\n\n// Bit register declaration\nbit[2] b\n\n// Gate\nH q[0]\n\n// Gate modifier\nctrl.X q[0], q[1]\n\n// Measure instruction\nb[0, 1] = measure q[0, 1]\n</code></pre> <pre><code>version 3\n</code></pre>"},{"location":"language_specification/general_overview.html#types","title":"Types","text":"<p>The set of types supported by cQASM can be found in the section Types. </p>"},{"location":"language_specification/general_overview.html#expressions","title":"Expressions","text":"<p>The following expressions can appear in a statement:</p> <ul> <li>Indices</li> <li>Predefined constants</li> <li>Built-in functions</li> </ul>"},{"location":"language_specification/general_overview.html#case-sensitivity","title":"Case sensitivity","text":"<p>cQASM is now a case-sensitive language, in contrast to previous versions.  The following lines of code are all semantically distinct</p> <pre><code>H q[0]\nh Q[0]\n</code></pre> <p>In the first line of the example above, the Hadamard gate <code>H</code> is applied to the qubit at index <code>0</code> of the qubit register <code>q</code>. The next line starts with an undefined gate <code>h</code>  that operates on the qubit at index <code>0</code> of the qubit register <code>Q</code>, which in turn does not refer to the qubit register <code>q</code>.</p> <p>Take care that case sensitivity not only applies to identifiers, but also to all other lexical components of the language, like keywords, types, predefined constants, and built-in functions.</p> <p>Note</p> <p>Gate names are identifiers and are therefore case-sensitive. The syntax of the gates defined in cQASM are listed in the cQASM standard gate set. Even though it is common practice to write variable names or function identifiers in lowercase, we choose to define the gate names in the predefined cQASM standard gate set in UPPERCASE or CamelCase, as this is more in line with how these gates are represented in the field of quantum information processing (QIP). </p>"},{"location":"language_specification/general_overview.html#file-extension","title":"File extension","text":"<p>The preferred file extension for a cQASM file is <code>*.cq</code>.</p>"},{"location":"language_specification/general_overview.html#how-to-read","title":"How to read","text":""},{"location":"language_specification/general_overview.html#grammar-sections","title":"Grammar sections","text":"<p>In the notation and grammar descriptions appearing throughout this language specification,  syntactic categories are indicated by italic type, and literal words and characters in <code>bold constant width</code> type. Alternatives are listed on separate lines except in a few cases where a long set of alternatives is presented on one line, with the quantifiers 'one of', 'through', or 'or'. For example,</p> <p>\u2003one of <code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code></p> <p>indicates any lowercase or uppercase alphabetic character.</p> <p>An optional terminal or non-terminal symbol is indicated by the subscript <sub>opt</sub>, so</p> <p> <code>{</code> expression<sub>opt</sub><code>}</code></p> <p>indicates an optional expression enclosed in curly braces.</p> <p>Names for syntactic categories have generally been chosen according to the following rules:</p> <ul> <li>X-sequence is one or more X\u2019s without intervening delimiters, e.g., digit-sequence is a sequence of digits.</li> <li>X-list is one or more X\u2019s separated by intervening commas, e.g., index-list is a sequence of  indices separated by commas.</li> </ul>"},{"location":"language_specification/general_overview.html#qubit-state-and-measurement-bit-ordering","title":"Qubit state and measurement bit ordering","text":"<p>In this specification, qubit states are represented using the ket-vector notation \\(|\\Psi\\rangle\\) and measurement outcomes are represented as bit strings.</p> <p>Qubits in a ket-vector are ordered with qubit indices decreasing from left to right, i.e., \\(|\\Psi\\rangle = \\sum c_i~(|q_n\\rangle\\otimes |q_{n-1}\\rangle\\otimes~...\\otimes~|q_1\\rangle\\otimes |q_0\\rangle)_i\\) \\(=\\sum c_i~|q_nq_{n-1}~...q_1q_0\\rangle_i\\). For example, given the state \\(|01\\rangle\\), \\(q_0\\) is in state \\(|1\\rangle\\) and \\(q_1\\) is in state \\(|0\\rangle\\). </p> <p>Measurement outcomes are represented by a bit string, which adheres to the same ordering convention as qubit states, i.e. with the (qu)bit indices decreasing from left to right.    </p> <p>Consider a qubit register of size 3, <code>qubit[3] q</code>, where each individual qubit can be referred to by its index as <code>q[0]</code>, <code>q[1]</code>, and <code>q[2]</code>. If the state of this qubit register is \\(|110\\rangle\\), then measuring it will result in the following bit string:</p> <code>q[2]</code> <code>q[1]</code> <code>q[0]</code> <code>1</code> <code>1</code> <code>0</code> <p>The same ordering applies to bit registers, i.e., for a bit register <code>b</code>, the ordering is given by <code>b[n-1]b[n]...b[1]b[0]</code>.</p>"},{"location":"language_specification/types.html","title":"Types","text":"<p>The table below lists the available types in a cQASM program.</p> Type Keyword Form Qubit <code>qubit</code> <code>qubit</code> identifier QubitArray <code>qubit</code> <code>qubit[</code>size<code>]</code>identifier Bit <code>bit</code> <code>bit</code> identifier BitArray <code>bit</code> <code>bit[</code>size<code>]</code>identifier <p>Note</p> <p>Type keywords are reserved and, therefore, cannot be used as identifiers.</p>"},{"location":"language_specification/expressions/builtin_functions.html","title":"Built-in functions","text":"<p>Coming soon</p>"},{"location":"language_specification/expressions/indices.html","title":"Indices","text":"<p>An index is a reference to one or more positions within a register. The first position of a register is 0. Positions are expressed as a list of comma-separated entries. Each entry can be a single integer or a range. A range is written as two integers separated by a colon, pointing to a first and to a last element within a register. The last position is also part of the range, i.e., it does not point to the first element out of the range.</p> <p>Grammar for indices</p> <p>index: identifier <code>[</code> index-list <code>]</code></p> <p>index-list: index-entry index-list <code>,</code> index-entry</p> <p>index-entry: integer-literal index-range</p> <p>index-range: index-entry <code>:</code> index-entry</p> <p>Indices, index entries, and index ranges</p> <pre><code>// Qubit register containing 7 qubits, numbered from 0 to 6\nqubit[7] q \n\n// q[1, 3:5] is a qubit index with two entries: \n// the first entry points to qubit 1 in q, and the second to qubits 3, 4, and 5\nH q[1, 3:5]\n</code></pre>"},{"location":"language_specification/expressions/predefined_constants.html","title":"Predefined constants","text":"<p>The following mathematical constants are recognized: <code>pi</code>, <code>tau</code>, and <code>eu</code>, where <code>tau</code> is \\(2\\pi\\) and <code>eu</code> represents Euler's constant \\(e\\). They are stored as floating-point number literals and can be used in arithmetic expressions with operators, e.g., <code>pi/2</code> equals \\(\\tfrac{\\pi}{2}\\). </p> <p>The latter can be used, for example, as an argument for a parameterized named gate, i.e., \u2003<code>Rx(pi/2) q[0]</code>.</p>"},{"location":"language_specification/statements/assembly_declaration.html","title":"Assembly declaration","text":"<p>Assembly declarations can be used to add backend-specific (assembly) code to a cQASM circuit. They are realized through an <code>asm</code> declaration statement. An <code>asm</code> declaration statement consists of the keyword <code>asm</code> with the identifier of the backend in parentheses, followed by the backend code. The latter is to be provided as a raw text string, which consists of a raw text delimited by opening and closing triple quotes (<code>'''</code>):</p> <p> <code>asm(</code>backend-identifier<code>)</code> backend-code</p> Grammar for assembly declaration <p>assembly-declaration: <code>asm(</code>backend-identifier<code>)</code> backend-code</p> <p>backend-identifier: identifier</p> <p>backend-code: raw-text-string</p> <p>As part of a cQASM circuit, the contents of the raw text string will be passed verbatim to the backend and ignored by all other consumers of the circuit.</p> <p>The location of the <code>asm</code> declaration in the cQASM circuit is preserved, i.e., no cQASM statements can be moved across it by any subsequent processing of the cQASM circuit. This allows for the ability to embed backend code into cQASM  with the guarantee that the relative order between cQASM and backend code remains the same.</p> <p>The following example shows how sections of code, specific to the example <code>Backend</code>, can be interlaced with cQASM statements:</p> <pre><code>version 3.0\n\nqubit[4] q\nbit[2]\n\nasm(Backend) '''\n    POS(0, 0) q[0]\n    POS(1, 0) q[1]\n    POS(0, 1) q[2]\n    POS(1, 1) q[3]\n'''\n\ninit q\n\nX q[0]\n\nasm(Backend) '''\n    PULSE(0.000467, -0.971166, 0.157596)\n    PULSE(0.001868, -0.942333, 0.157596)\n    PULSE(0.004196, -0.913500, 0.157596)\n    PULSE(0.007442, -0.884666, 0.157596)\n'''\n\nH q\nCNOT q[0], q[1]\n\nb = measure q[0, 1]\n</code></pre>"},{"location":"language_specification/statements/version_statement.html","title":"Version statement","text":"<p>The version statement is mandatory and indicates which version of the cQASM language the program is written in. Apart from comments, it must be the first statement of the program and occur only once. It has the following general form:</p> <p> <code>version</code> major-version<code>.</code>minor-version</p> Grammar for version statement <p>version: <code>version</code> major-version minor-version-suffix<sub>opt</sub></p> <p>major-version: digit-sequence</p> <p>minor-version-suffix: <code>.</code> minor-version</p> <p>minor-version: digit-sequence</p> <p>where the version number is to be given as two period separated integers, respectively indicating the major and minor version of the cQASM language. It is permitted to only specify the major version number, i.e., the specification of the minor version number is optional. In that case, the minor-version will be interpreted as <code>0</code>.</p> <p>Example</p> <pre><code>// Only comments may appear before the version statement.\nversion 3.0\n</code></pre>"},{"location":"language_specification/statements/instructions/single-gate-multiple-qubit-notation.html","title":"Single-gate-multiple-qubit (SGMQ) notation","text":"<p>It is possible to pass multiple qubits as an argument to a single-qubit gate, by making use of the single-gate-multiple-qubit (SGMQ) notation. The single-qubit gate will then be applied to each qubit, respectively.</p> <p>Note</p> <p>SGMQ notation does not imply that the gates are, necessarily, executed in parallel on the target device.  SGMQ notation is nothing other than syntactic sugar, whereby a series of instruction statements can be written as one. Moreover, SGMQ notation should not be confused with multiple-qubit gates, e.g.,  <code>X q[0,1]</code> means <code>X q[0]; X q[1]</code>, and does not represent the 2-qubit gate <code>XX q[0], q[1]</code>. Note that the latter 2-qubit gate <code>XX</code> is currently not supported by the cQASM language, see the standard gate set below.</p> <p>If the name of the qubit register is <code>q</code>, then the following can be passed as an argument to the single-qubit gate:</p> <ul> <li> <p>the whole qubit register <code>q</code>;</p> </li> <li> <p>a slice thereof <code>q[i:j]</code>, where \\(0 \\leq i &lt; j &lt; N\\);</p> </li> <li> <p>or a list of indices can be passed <code>q[i,]</code>, where \\(0 \\leq i &lt; N\\),</p> </li> </ul> <p>with \\(N\\) the size of the qubit register. The following slicing convention is adopted: a slice <code>q[i:j]</code> includes qubits <code>q[i]</code>, <code>q[j]</code>, and all qubits in between. The code block below demonstrates some examples.</p> <p>Example</p> The whole qubit registerA slice of the qubit registerA list of indices of the qubit register <pre><code>qubit[5] q\n\nX q  // is semantically equivalent to:\nX q[0]; X q[1]; X q[2]; X q[3]; X q[4]\n</code></pre> <pre><code>qubit[5] q\n\nX q[1:3]  // is semantically equivalent to:\nX q[1]; X q[2]; X q[3]\n</code></pre> <pre><code>qubit[5] q\n\nX q[0,2,4]  // is semantically equivalent to:\nX q[0]; X q[2]; X q[4] \n</code></pre> <p>In the above examples we have used the semicolon <code>;</code> to separate statements occurring on the same line.</p>"},{"location":"language_specification/statements/instructions/unitary_instructions.html","title":"Unitary instructions","text":"<p>Unitary instructions, commonly known as gates, define single-qubit or multi-qubit operations that change the state of a qubit register in a reversible and deterministic fashion. They include:</p> <ul> <li>named gates, or</li> <li>compositions of gate modifiers acting on a named gate.</li> </ul> <p>Note that a composition of gate modifiers acting on a named gate is itself a gate. </p> Grammar for unitary instructions <p>unitary-instruction: gate qubit-arguments </p> <p>gate: inv-gate pow-gate ctrl-gate named-gate </p> <p>inv-gate: <code>inv.</code>gate</p> <p>pow-gate: <code>pow(</code>parameter<code>).</code>gate</p> <p>ctrl-gate: <code>ctrl.</code>gate</p> <p>named-gate: identifier parameters<sub>opt</sub> </p> <p>parameters: <code>(</code> parameter-list <code>)</code></p> <p>parameter-list: parameter parameter-list <code>,</code> parameter</p> <p>parameter: integer-literal floating-literal</p> <p>qubit-arguments: qubit-argument-list</p> <p>qubit-argument-list: qubit-argument qubit-argument-list <code>,</code> qubit-argument</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p>"},{"location":"language_specification/statements/instructions/unitary_instructions.html#named-gates","title":"Named gates","text":"<p>Named gates comprise particular unitary operations that have been given their own unique label, e.g., the Hadamard gate <code>H</code> or the controlled-not gate <code>CNOT</code>. In general, we simply refer to them as gates. All recognized (named) gates are listed in the standard gate set. Moreover, we use the term named gate to distinguish them from unitary operations consisting of compositions of gate modifiers acting on a named gate, i.e., modified gates. Named gates are, thus, unmodified gates and can simply be used on their own or modified (multiple times) through gate modifiers. </p> <p>The general form of a named gate is given by the gate name followed by the (comma-separated list of) qubit operand(s), e.g., <code>X q[0]</code>:</p> <p> gate qubit-arguments</p> <p>A named gate can be parameterized. The general form of a parameterized gate is given by the gate name followed by its (comma-separated list of) parameter(s) that is enclosed in parentheses, which in turn is followed by the (comma-separated list of) qubit operand(s), e.g., <code>CRk(2) q[0], q[1]</code>:</p> <p> gate<code>(</code>parameters<code>)</code> qubit-arguments</p> <p>Note that the parameters, either single or a list of multiple parameters, appear within parentheses directly following the gate name. We distinguish between the parameters of a parameterized gate, in terms of number literals, and the qubit arguments that a (parameterized) gate acts on.</p> <p>A few examples of gates are shown below.</p> <pre><code>// A single-qubit Hadamard gate\nH q[0]\n\n// A two-qubit controlled-Z gate (control: q[0], target: q[1])\nCZ q[0], q[1]\n\n// A parameterized single-qubit Rx gate (with \u03c0/2 rotation around the x-axis)\nRx(pi/2) q[0]\n\n// A parametrized two-qubit controlled phase-shift gate (control: q[1], target: q[0])\nCRk(2) q[1], q[0]\n</code></pre>"},{"location":"language_specification/statements/instructions/unitary_instructions.html#standard-gate-set","title":"Standard gate set","text":"Name Description Example statement I Identity gate <code>I q[0]</code> H Hadamard gate <code>H q[0]</code> X Pauli-X <code>X q[0]</code> X90 Rotation around the x-axis of \\(\\pi/2\\) <code>X90 q[0]</code> mX90 Rotation around the x-axis of \\(-\\pi/2\\) <code>mX90 q[0]</code> Y Pauli-Y <code>Y q[0]</code> Y90 Rotation around the y-axis of \\(\\pi/2\\) <code>Y90 q[0]</code> mY90 Rotation around the y-axis of \\(-\\pi/2\\) <code>mY90 q[0]</code> Z Pauli-Z <code>Z q[0]</code> S Phase gate <code>S q[0]</code> Sdag S dagger gate <code>Sdag q[0]</code> T T <code>T q[0]</code> Tdag T dagger gate <code>Tdag q[0]</code> Rx Arbitrary rotation around x-axis <code>Rx(pi) q[0]</code> Ry Arbitrary rotation around y-axis <code>Ry(pi) q[0]</code> Rz Arbitrary rotation around z-axis <code>Rz(pi) q[0]</code> CNOT Controlled-NOT gate <code>CNOT q[0], q[1]</code> CZ Controlled-Z, Controlled-Phase <code>CZ q[0], q[1]</code> CR Controlled phase shift (arbitrary angle) <code>CR(pi) q[0], q[1]</code> CRk Controlled phase shift (\\(\\pi/2^{k-1}\\)) <code>CRk(2) q[0], q[1]</code> SWAP Swap gate <code>SWAP q[0], q[1]</code>"},{"location":"language_specification/statements/instructions/unitary_instructions.html#gate-modifiers","title":"Gate modifiers","text":"<p>A gate modifier is an operator Q that takes a gate as input and returns a modified gate as output (Q: gate \u2192 gate), i.e., it transforms an arbitrary unitary \\(U\\) into \\(U'\\), based on the particular modifier that is applied. We consider the following gate modifiers:</p> <ul> <li>The inverse modifier <code>inv</code>, which modifies the gate \\(U\\) into \\(U^\\dagger\\), e.g., <code>inv.X q[0]</code>.</li> <li>The power modifier <code>pow</code>, which raises the gate \\(U\\) to the specified power \\(a\\), i.e., \\(U^a\\),   where \\(a\\) is a float, e.g., <code>pow(pi/2).X q[0]</code>.</li> <li>The control modifier <code>ctrl</code>, which changes the gate \\(U\\) into the controlled-\\(U\\) gate, e.g.,   <code>ctrl.X q[0], q[1]</code>, where the control qubit is prepended to the list of qubit operands. </li> </ul> <p>Since gate modifiers return gates, they can be applied in a nested manner, e.g., <code>inv.pow(2).X</code>, where a gate modifier <code>inv</code> is applied to the modified gate <code>pow(2).X</code>, which in turn resulted from applying the gate modifier <code>pow(2)</code> on the (named) gate <code>X</code>.</p> <p>The current version of the language only allows gate modifiers to act on single-qubit gates.</p> <p> <code>inv.</code>gate qubit-argument <code>pow(</code>exponent<code>).</code>gate qubit-argument <code>ctrl.</code>gate qubit-arguments</p> <p>A few examples of gates are shown below.</p> <pre><code>// Inverse of X\ninv.X q\n\n// S gate implemented as a power of T\npow(2).T q\n\n// CZ implemented as a controlled-Z\nctrl.Z q[0], q[1]\n\n// Composition of gate modifiers (modifiers are applied from right to left)\nctrl.pow(1/2).inv.X q[0], q[1]\n</code></pre> <p>Notice that, <code>inv</code> and <code>pow</code> map an n-qubit gate to an n-qubit gate, and <code>ctrl</code> maps an n-qubit gate to a (n+1)-qubit gate.</p> <p>Warning</p> <p>The current version of the language does not support the use of gate modifiers on multi-qubit gates. For example, the following instructions are not supported:</p> <ul> <li><code>inv.CRk(2) q[0], q[1]</code>, where the inverse modifier is applied to a two-qubit named gate.</li> <li><code>inv.ctrl.X q[0], q[1]</code>, where the inverse modifier is applied to a two-qubit modified gate.</li> </ul> <p>Considering the latter example, note that the following use of gate modifiers is permitted:</p> <ul> <li><code>ctrl.inv.X q[0], q[1]</code>, since the inverse modifier is first applied to the single-qubit named gate <code>X</code>, resulting in a single-qubit modified gate, which only then is modified through the control modifier into a two-qubit modified gate.</li> </ul>"},{"location":"language_specification/statements/instructions/control_instructions/barrier_instruction.html","title":"Barrier instruction","text":"<p>The <code>barrier</code> instruction is a single-qubit control instruction that is used to constrain the optimization of a scheduler. It tells a scheduler that instructions on the specified qubit(s) cannot be scheduled across the barrier. See the <code>wait</code> instruction, to impose a time delay following a barrier.</p> <p>The general form of the <code>barrier</code> instruction is as follows:</p> <p> <code>barrier</code> qubit-argument</p> Grammar for <code>barrier</code> instruction <p>barrier-instruction: <code>barrier</code> qubit-argument</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Note</p> <p>The <code>barrier</code> instruction accepts SGMQ notation. SGMQ notation allows you to express the application of an instruction to multiple qubits. However, SGMQ notation does not guarantee simultaneity. In general, a compiler will unpack this notation to separate consecutive single-qubit instructions on each respective qubit. This will depend on the scheduling optimization that is applied during the compilation process.</p> <p>For certain backends, groups of consecutive <code>barrier</code> instructions are linked together to form a uniform barrier, across which no instructions on the specified qubits can be scheduled. Note that one can create a group of consecutive <code>barrier</code> instructions, i.e. a uniform barrier, using SGMQ notation.</p> <p>Example</p> Single qubitMultiple qubits <pre><code>qubit q\nX q\nbarrier q\nX q\n</code></pre> <pre><code>qubit[3] q\nX q[0]\nbarrier q[0, 1]\nH q[0]\nX q[2]\nH q[1]\n</code></pre> <p>In the examples above it is shown how the <code>barrier</code> instruction can be used with a single qubit and multiple qubits. In the case of the single qubit, an optimizer would generally fuse the two <code>X</code> gates into a single identity gate, <code>I</code>. However, because of the presence of the <code>barrier</code> instruction, the user explicitly states that the instructions on <code>q</code> are not permitted to be optimized across the barrier. The second example shows that a barrier can be placed for multiple qubits. Note that the <code>barrier</code> instruction is applied to qubits <code>q[0]</code> and <code>q[1]</code>. Qubit <code>q[2]</code> can be optimized freely across this circuit, i.e., be scheduled before or after the barrier. </p> <p>The following code snippet illustrates how the <code>barrier</code> instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\ninit q\n\n// Phi+ state\nH q[0]\nCNOT q[0], q[1]\nbarrier q\nb[0,1] = measure q\n\nbarrier q\nreset q\n\n// Psi+ state\nH q[0]\nX q[1]\nCNOT q[0], q[1]\nbarrier q\nb[2, 3] = measure q\n</code></pre> <p>In the above code snippet, the \\(\\Phi_{+}\\) and \\(\\Psi_{+}\\) Bell states are generated and measured, successively. The <code>barrier</code> instruction is used to guarantee that the <code>measure</code> instruction is scheduled after the respective states have been generated.  Moreover, an extra <code>barrier</code> instruction is used to separate the generation and measurement of the two Bell states.</p>"},{"location":"language_specification/statements/instructions/control_instructions/wait_instruction.html","title":"Wait instruction","text":"<p>The <code>wait</code> instruction is a single-qubit control instruction that is used to constrain the optimization of a scheduler. It tells the scheduler to delay the subsequent instructions on the specified qubit(s) by a given time. The delay time is passed along with the instruction as a dimensionless parameter, the unit of which represents the duration of a single-qubit gate on the backend, i.e., an execution cycle.  Moreover, the <code>wait</code> instruction will also function as a barrier, telling the scheduler that instructions on the specified qubit(s) cannot be scheduled across the position of the  <code>wait</code> instruction.</p> <p>Warning</p> <p>The <code>barrier</code> instruction may be considered equal to the <code>wait</code> instruction with a time delay set to 0. Note however that for certain backends, groups of consecutive <code>barrier</code> instructions are linked together to form a uniform barrier, across which no instructions on the specified qubits can be scheduled. This is not the case for the <code>wait</code> instruction; consecutive <code>wait</code> instructions on different qubits are considered to be independent instructions.</p> <p>Multiple successive <code>wait</code> instructions on the same qubit, however, may be fused into a single <code>wait</code> instruction, where the delay time is set to the sum of the delay times of the separate instructions. For example,</p> <pre><code>wait(3) q[0]\nwait(4) q[1]\nwait(2) q[0]\n</code></pre> <p>could be optimized to:</p> <pre><code>wait(5) q[0]\nwait(4) q[1]\n</code></pre> <p>The general form of the <code>wait</code> instruction is as follows:</p> <p> <code>wait(</code> parameter <code>)</code> qubit-argument</p> Grammar for <code>wait</code> instruction <p>wait-instruction: <code>wait(</code> parameter <code>)</code> qubit-argument</p> <p>parameter: integer-literal </p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Note</p> <p>The <code>wait</code> instruction accepts SGMQ notation, similar to gates.</p> <p>Example</p> Single qubitMultiple qubits <pre><code>qubit q\nX q\nwait(5) q  // time delay of 5 execution cycles\nX q\n</code></pre> <pre><code>qubit[3] q\nX q[0]\nwait(5) q[0, 1]  // time delay of 5 execution cycles\nH q[0]\nX q[2]\nH q[1]\n</code></pre> <p>In the examples above it is shown how the <code>wait</code> instruction can be used with a single qubit and multiple qubits. In the case of the single qubit, the <code>wait</code> instruction tells the scheduler to schedule a delay of 5 execution cycles between the successive <code>X</code> gates. Note that it also implicitly places a barrier between the two <code>X</code> gates, such that they cannot be fused into a single identity gate, <code>I</code>. In the second example, using SGMQ notation, the <code>wait</code> instruction is applied to qubits <code>q[0]</code> and <code>q[1]</code>. Enforcing a delay of 5 execution cycles on any following instructions involving those qubits, e.g., here <code>H q[0]</code> and <code>H q[1]</code>. Qubit <code>q[2]</code> can be optimized freely across this circuit, i.e., be scheduled before or after <code>wait</code> instruction, regardless of any specified time delay. </p> <p>The following code snippet illustrates how the <code>wait</code> instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\ninit q\n\nwait(100) q[0]\nb[0] = measure q[0]\n</code></pre> <p>Here, the measurement of <code>q[0]</code> is forced to be scheduled at least 100 execution cycles after the initialization of the qubit is complete.</p>"},{"location":"language_specification/statements/instructions/non_unitary_instructions/init_instruction.html","title":"Init instruction","text":"<p>In general, qubits are initialized in the \\(|0\\rangle\\) state. Nonetheless, to explicitly initialize (particular) qubits in the \\(|0\\rangle\\) state one can use the <code>init</code> instruction. The general form of an <code>init</code> instruction is as follows:</p> <p> <code>init</code> qubit-argument</p> Grammar for <code>init</code> instruction <p>init-instruction: <code>init</code> qubit-argument</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Example</p> Initialize a single qubitInitialize multiple qubits through their register index <pre><code>qubit q\ninit q\n</code></pre> <pre><code>qubit[5] q\ninit q[2, 4]\n</code></pre> <p>Note</p> <p>The <code>init</code> instruction accepts SGMQ notation, similar to gates.</p> <p>The following code snippet shows how the <code>init</code> instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\ninit q  // Initializes the qubits to |0&gt;\n\nH q[0]\nCNOT q[0], q[1]\n\nb = measure q\n</code></pre> <p>In the code example above, the qubits are first declared and subsequently initialized. Note that the initialization of qubits needs to be done before any instruction (excluding a control instruction) is applied to them (see warning below). If one wishes to reset the state of the qubit to \\(|0\\rangle\\) mid-circuit, one should use the <code>reset</code> instruction.</p> <p>Warning</p> <p>Initialization of a qubit can only be done immediately after declaration of the qubit, i.e.,  it is not possible to initialize a qubit, if prior to that an instruction was applied to the qubit (excluding a control instruction).</p> Invalid initializationValid initialization <pre><code>version 3.0\n\nqubit[2] q\n\nbarrier q  // Control instructions may be applied to qubits before initialization\nH q[1]\n\ninit q[1]  // Invalid use, since the H gate was applied to q[1] before initialization\n</code></pre> <pre><code>version 3.0\n\nqubit[2] q\n\nbarrier q  // Control instructions may be applied to qubits before initialization\nH q[1]\n\ninit q[0]  // Valid use, because no instruction is applied to q[0] before initalization\n</code></pre>"},{"location":"language_specification/statements/instructions/non_unitary_instructions/measure_instruction.html","title":"Measure instruction","text":"<p>A <code>measure</code> instruction performs a measurement to its qubit argument and assigns the outcome to a bit variable. The general form of a <code>measure</code> instruction is as follows:</p> <p> bit-argument <code>=</code> <code>measure</code> qubit-argument</p> Grammar for <code>measure</code> instruction <p>measure-instruction: bit-argument <code>=</code> <code>measure</code> qubit-argument</p> <p>bit-argument: bit-variable bit-index</p> <p>bit-variable: identifier</p> <p>bit-index: index</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Example</p> Measurement of a single qubitMeasurement of multiple qubits through their register index <pre><code>qubit q\nbit b\nb = measure q\n</code></pre> <pre><code>qubit[5] q\nbit[2] b\nb[0, 1] = measure q[2, 4]\n</code></pre> <p>Note</p> <p>The <code>measure</code> instruction accepts SGMQ notation, similar to gates.</p> <p>The following code snippet shows how the <code>measure</code> instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\n\nb = measure q  // Measurement in the standard basis.\n</code></pre> <p>On the last line of this simple cQASM program, the respective states of both qubits in the qubit register are measured along the standard/computational basis.</p>"},{"location":"language_specification/statements/instructions/non_unitary_instructions/reset_instruction.html","title":"Reset instruction","text":"<p>A <code>reset</code> instruction resets the state of the qubit to \\(|0\\rangle\\). It does this by first measuring the qubit and then, conditioned on the outcome being 1, applying a Pauli X gate.</p> <p>Note</p> <p>Even though the <code>reset</code> instruction internally measures the qubit state, it does not store the measurement outcome in the measurement register, i.e., the measurement register is unaffected by the <code>reset</code> instruction. The measurement outcome is only used to determine whether or not a Pauli X gate needs to be performed, in order to bring the qubit into the state \\(|0\\rangle\\).</p> <p>The general form of a <code>reset</code> instruction is as follows:</p> <p> <code>reset</code> qubit-argument</p> Grammar for <code>reset</code> instruction <p>reset-instruction: <code>reset</code> qubit-argument</p> <p>qubit-argument: qubit-variable qubit-index</p> <p>qubit-variable: identifier</p> <p>qubit-index: index</p> <p>Example</p> Reset of a single qubitReset of multiple qubits through their register index <pre><code>qubit q\nreset q\n</code></pre> <pre><code>qubit[5] q\nreset q[2, 4]\n</code></pre> <p>Note</p> <p>The <code>reset</code> instruction accepts SGMQ notation, similar to gates.</p> <p>The following code snippet shows how the <code>reset</code> instruction might be used in context.</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\n\nreset q[0]  // Resets the state of qubit q[0] to |0&gt;\n\nb = measure q\n</code></pre> <p>The <code>reset</code> instruction is performed by measuring <code>q[0]</code> along the computational basis. Based on the measurement outcome, either no operation is performed (in case the outcome is 0) or a Pauli X gate is applied (in case the outcome is 1). The result of the subsequent <code>measure</code> instruction will be <code>00</code> in roughly half of the cases and <code>10</code> in the remaining cases, with the qubit register indices decreasing from left to right, i.e., <code>q[n]...q[0]</code>.</p> <p>Info</p> <p>Qubits that are part of an entangled state, are disentangled from that state, when the <code>reset</code> instruction is applied to them.</p>"},{"location":"language_specification/statements/variable_declarations/bit_register_declaration.html","title":"Bit (register) declaration","text":"<p>A bit or bit register must be declared before they can be used. The general form is given as follows:</p> <p> <code>bit[</code>size<code>]</code>identifier</p> Grammar for bit (register) declaration <p>bit-declaration: <code>bit</code> array-size-declaration<sub>opt</sub> identifier</p> <p>array-size-declaration: <code>[</code>integer-literal<code>]</code> </p> <p>Its form is similar to the declaration of an arbitrary variable, whereby the type of the variable is specified first, i.e. <code>bit</code> denotes that the declared variable is of type Bit. and <code>bit[</code>size<code>]</code> denotes that the declared variable is of type BitArray. The size of a bit register is declared by an integer value between square brackets <code>[</code>size<code>]</code>. The name of the bit (register) is defined through an identifier. </p> <p>The declaration of a bit (register) is optional, Nevertheless, since measurement outcomes are stored as bits, measure instructions require a previously declared bit (register).</p> <p>Find below examples, respectively, of a single bit declaration and bit register declaration.</p> <p>Example</p> Single bit declarationBit register declaration <pre><code>version 3\n\nqubit q\nqubit b  // Single bit declaration of a bit named 'b'.\n\nH q\n\nb = measure q\n</code></pre> <pre><code>version 3\n\nqubit[5] q\nbit[2] b  // Bit register declaration of a register containing 2 bits, named 'b'.\n\nH q[0]\nCNOT q[0], q[1]\n\nb[0] = measure q[0]\nb[1] = measure q[1]\n</code></pre> <p>The individual bits of a bit register can be referred to by their register index, e.g. in the example of the Bit register declaration, the statement <code>b[0] = measure q[0]</code> indicates that the measurement outcome is stored at the bit located at index <code>0</code> of the bit register <code>b</code>.  Note that in the case of a single bit, the bit is referred to through its identifier, not through a register index.</p>"},{"location":"language_specification/statements/variable_declarations/qubit_register_declaration.html","title":"Qubit (register) declaration","text":"<p>A qubit (register) must be declared before it can be used. The general form is given as follows:</p> <p> <code>qubit[</code>size<code>]</code>identifier</p> Grammar for bit (register) declaration <p>qubit-declaration: <code>qubit</code> array-size-declaration<sub>opt</sub> identifier</p> <p>array-size-declaration: <code>[</code> integer-literal <code>]</code> </p> <p>Its form is similar to the declaration of an arbitrary variable, whereby the type of the variable is specified first, i.e. <code>qubit</code> denotes that the declared variable is of type Qubit. and <code>qubit[</code>size<code>]</code> denotes that the declared variable is of type QubitArray. The size of a qubit register is declared by an integer value between square brackets <code>[</code>size<code>]</code>. The name of the qubit (register) is defined through an identifier. </p> <p>The declaration of a qubit (register) is optional. </p> <p>Note</p> <p>The qubit (register) declaration replaces the qubit statement, i.e., </p> <p> <code>qubits</code> size</p> <p>of previous versions of the cQASM language.</p> <p>Find below examples, respectively, of a single qubit declaration and qubit register declaration.</p> <p>Example</p> Single qubit declarationQubit register declaration <pre><code>version 3\n\nqubit q  // Single qubit declaration of a qubit named 'q'.\nqubit b\n\nH q\n\nb = measure q\n</code></pre> <pre><code>version 3\n\nqubit[5] q  // Qubit register declaration of a register containing 5 qubits, named 'q'.\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\n\nb[0, 1] = measure q[0, 1]\n</code></pre> <p>The individual qubits of a qubit register can be referred to by their register index, e.g., in the example of the Qubit register declaration, the statement <code>H q[0]</code> indicates the application of a Hadamard gate <code>H</code> on the qubit located at index <code>0</code> of the qubit register <code>q</code>.  Note that in the case of a single qubit,  the qubit is referred to through its identifier, not through a register index.</p> <p>Qubits, either declared as a single qubit or as elements of a register, are presumed to be initialized in the state \\(|0\\rangle\\) of the standard/computational basis.</p>"},{"location":"language_specification/tokens/identifiers.html","title":"Identifiers","text":"<p>An identifier is a single character or a sequence of characters of the following form: upper or lowercase letters from the ISO basic Latin alphabet, underscore, and digits, with the constraint that the first (or singular) character cannot be a digit.</p> <p>For now, they are used to name qubits and bits (registers) by the user, and predefine the names of useful mathematical constants, built-in functions, and named gates. Note that identifiers are not protected, i.e. they can be reused.  For example, it is permissible, however discouraged, to name a (qu)bit (register) <code>pi</code>, <code>cos</code>, or <code>Rx</code>.</p> <p>Reserved keywords cannot be used as an identifier.</p> Grammar for identifiers <p>identifier: letter identifier letter identifier digit</p> <p>letter:  one of <code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code> or <code>_</code> </p> <p>Examples</p> Valid identifiersInvalid identifiers <pre><code>q\n_i\nID\nb01\n</code></pre> <pre><code>1q     // first character cannot be a digit\n+q     // the underscore '_' is the only permissible special character \nqubit  // 'qubit' is a reserved keyword\n</code></pre>"},{"location":"language_specification/tokens/keywords.html","title":"Keywords","text":"<p>Keywords constitute identifiers reserved by the language parser.  As such, they have a specific predefined meaning and cannot be overwritten or used as a general identifier, e.g., as the name of the (qu)bit register.</p> <p>The table below lists the reserved keywords in cQASM:</p> Keyword Use <code>version</code> Version statement <code>qubit</code> Qubit type <code>bit</code> Bit type <code>init</code> Init instruction <code>reset</code> Reset instruction <code>measure</code> Measure instruction <code>wait</code> Wait control instruction <code>barrier</code> Barrier control instruction <code>ctrl</code> Control gate modifier <code>inv</code> Inverse gate modifier <code>pow</code> Power gate modifier <code>asm</code> Assembly declaration"},{"location":"language_specification/tokens/literals.html","title":"Literals","text":"<p>The only literals accepted as tokens are integer and float numbers. </p> Literal Size / precision Integer 64-bit signed Float IEEE 754 double precision Grammar of number literals <p>integer-literal: digit-sequence</p> <p>floating-literal: digit-sequence <code>.</code> digit-sequence exponent<sub>opt</sub> digit-sequence <code>.</code> exponent<sub>opt</sub> <code>.</code> digit-sequence exponent<sub>opt</sub></p> <p>exponent: <code>e</code> sign<sub>opt</sub> digit-sequence <code>E</code> sign<sub>opt</sub> digit-sequence</p> <p>sign: one of <code>+</code> <code>-</code></p> <p>digit-sequence: digit digit-sequence digit</p> <p>digit: one of <code>0</code> through <code>9</code> </p>"},{"location":"language_specification/tokens/newlines.html","title":"Newlines","text":"<p>cQASM is newline-sensitive, i.e. a newline terminates a statement.</p> <p>A semicolon <code>;</code> may be used instead of a newline to separate statements, for instance when putting multiple statements on the same line. Semicolons can also be put at the end of the line for clarity without changing the semantics of the program.</p>"},{"location":"language_specification/tokens/operators_and_punctuators.html","title":"Operators and punctuators","text":"<p>The lexical representation of a cQASM program includes a number of tokens that serve as operators and punctuators.</p> <p>Grammar of operators and punctuators</p> <p>operators-and-punctuators: one of <code>;</code> <code>:</code> <code>,</code> <code>.</code> <code>=</code> <code>[</code> <code>]</code> <code>(</code> <code>)</code> <code>'''</code> <code>+</code> <code>-</code> <code>~</code> <code>!</code> <code>\\*\\*</code> <code>\\*</code> <code>/</code> <code>%</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code> <code>&amp;</code> <code>^</code> <code>|</code> <code>&amp;&amp;</code> <code>^^</code> <code>||</code> <code>?</code></p>"},{"location":"language_specification/tokens/raw_text_string.html","title":"Raw text string","text":"<p>A raw text string is a sequence of zero or more characters delimited by triple quotes. Any character, including whitespaces, comments, and newlines, can be part of a raw text string.</p> Grammar for raw text string <p>raw-text-string: <code>'''</code> raw-text<sub>opt</sub> <code>'''</code></p> <p>raw-text: \u2003 raw-char \u2003 raw-text raw-char</p> <p>raw-char: \u2003 any character</p> <p>Warning</p> <p>Even though any sequence of characters could be raw text, one should avoid using triple qoutes (<code>'''</code>) as they will be interpreted as the delimiters of the raw text string.</p>"},{"location":"language_specification/tokens/whitespace_and_comments.html","title":"Whitespace and comments","text":"<p>In general, cQASM is not whitespace-sensitive, apart from newlines. Spaces and tabs can be placed in between tokens.</p> <p>Comments can be written as single-line comments or as multi-line comments within a comment block. Only comments can appear before the version statement. Whitespace before a single-line or multi-line comment is permitted.</p>"},{"location":"language_specification/tokens/whitespace_and_comments.html#single-line-comment","title":"Single-line comment","text":"<p>A single-line comment is prefixed by two forward slashes <code>//</code> and finishes with the new line,  equal to the syntax of C-like languages.</p> <p>The general form of single-line comments is as follows</p> <p> <code>//</code> single-line-comment statement statement <code>//</code> single-line-comment</p> <p>Example</p> <pre><code>// This is a single-line comment, which ends on the new line.\nH q[0]\nCNOT q[0], q[1]  // A single-line comment can follow a statement.\n</code></pre>"},{"location":"language_specification/tokens/whitespace_and_comments.html#multi-line-comments","title":"Multi-line comments","text":"<p>Multi-line comment blocks allow for writing comments that span multiple lines.  A comment block starts with the combination of a forward slash and an asterisk <code>/*</code> and end with the combination of an asterisk and a forward slash <code>*/</code>.</p> <p>The general structure of a multi-line comment is given by</p> <p> <code>/*</code> multi-line comment-block <code>*/</code> </p> <p> statement <code>/*</code> multi-line comment-block <code>*/</code> statement</p> <p>An example of multi-line commenting is given by the following:</p> <p>Example</p> <pre><code>/* This is a multi-\nline comment. */\nCNOT q[0], /* A comment block can\nbe placed in between tokens. */ q[1]\n</code></pre> <p>A pair of forward slashes <code>//</code> may be part of a multi-line comment block. In that case they are considered part of the comment and not the start of a single-line comment.</p>"}]}